{"version":3,"sources":["../../../../../next-server/lib/router/utils/prepare-destination.ts"],"names":["prepareDestination","destination","params","query","appendParamsToQuery","basePath","parsedDestination","Object","assign","__nextLocale","startsWith","pathname","searchParams","hash","hostname","port","protocol","search","href","URL","destQuery","destPath","destPathParamKeys","pathToRegexp","destPathParams","map","key","name","destinationCompiler","compile","validate","newUrl","strOrArray","entries","value","Array","isArray","queryCompiler","substr","paramKeys","keys","some","includes","shouldAddBasePath","split","err","message","match","Error"],"mappings":"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","sourcesContent":["import { ParsedUrlQuery } from 'querystring'\nimport { searchParamsToUrlQuery } from './querystring'\nimport { parseRelativeUrl } from './parse-relative-url'\nimport * as pathToRegexp from 'next/dist/compiled/path-to-regexp'\n\ntype Params = { [param: string]: any }\n\nexport default function prepareDestination(\n  destination: string,\n  params: Params,\n  query: ParsedUrlQuery,\n  appendParamsToQuery: boolean,\n  basePath: string\n) {\n  let parsedDestination: {\n    query?: ParsedUrlQuery\n    protocol?: string\n    hostname?: string\n    port?: string\n  } & ReturnType<typeof parseRelativeUrl> = {} as any\n\n  // clone query so we don't modify the original\n  query = Object.assign({}, query)\n  delete query.__nextLocale\n\n  if (destination.startsWith('/')) {\n    parsedDestination = parseRelativeUrl(destination)\n  } else {\n    const {\n      pathname,\n      searchParams,\n      hash,\n      hostname,\n      port,\n      protocol,\n      search,\n      href,\n    } = new URL(destination)\n\n    parsedDestination = {\n      pathname,\n      query: searchParamsToUrlQuery(searchParams),\n      hash,\n      protocol,\n      hostname,\n      port,\n      search,\n      href,\n    }\n  }\n\n  const destQuery = parsedDestination.query\n  const destPath = `${parsedDestination.pathname!}${\n    parsedDestination.hash || ''\n  }`\n  const destPathParamKeys: pathToRegexp.Key[] = []\n  pathToRegexp.pathToRegexp(destPath, destPathParamKeys)\n\n  const destPathParams = destPathParamKeys.map((key) => key.name)\n\n  let destinationCompiler = pathToRegexp.compile(\n    destPath,\n    // we don't validate while compiling the destination since we should\n    // have already validated before we got to this point and validating\n    // breaks compiling destinations with named pattern params from the source\n    // e.g. /something:hello(.*) -> /another/:hello is broken with validation\n    // since compile validation is meant for reversing and not for inserting\n    // params from a separate path-regex into another\n    { validate: false }\n  )\n  let newUrl\n\n  // update any params in query values\n  for (const [key, strOrArray] of Object.entries(destQuery)) {\n    let value = Array.isArray(strOrArray) ? strOrArray[0] : strOrArray\n    if (value) {\n      // the value needs to start with a forward-slash to be compiled\n      // correctly\n      value = `/${value}`\n      const queryCompiler = pathToRegexp.compile(value, { validate: false })\n      value = queryCompiler(params).substr(1)\n    }\n    destQuery[key] = value\n  }\n\n  // add path params to query if it's not a redirect and not\n  // already defined in destination query or path\n  const paramKeys = Object.keys(params)\n\n  if (\n    appendParamsToQuery &&\n    !paramKeys.some((key) => destPathParams.includes(key))\n  ) {\n    for (const key of paramKeys) {\n      if (!(key in destQuery)) {\n        destQuery[key] = params[key]\n      }\n    }\n  }\n\n  const shouldAddBasePath = destination.startsWith('/') && basePath\n\n  try {\n    newUrl = `${shouldAddBasePath ? basePath : ''}${destinationCompiler(\n      params\n    )}`\n\n    const [pathname, hash] = newUrl.split('#')\n    parsedDestination.pathname = pathname\n    parsedDestination.hash = `${hash ? '#' : ''}${hash || ''}`\n    delete parsedDestination.search\n  } catch (err) {\n    if (err.message.match(/Expected .*? to not repeat, but got an array/)) {\n      throw new Error(\n        `To use a multi-match in the destination you must add \\`*\\` at the end of the param name to signify it should repeat. https://err.sh/vercel/next.js/invalid-multi-match`\n      )\n    }\n    throw err\n  }\n\n  // Query merge order lowest priority to highest\n  // 1. initial URL query values\n  // 2. path segment values\n  // 3. destination specified query values\n  parsedDestination.query = {\n    ...query,\n    ...parsedDestination.query,\n  }\n\n  return {\n    newUrl,\n    parsedDestination,\n  }\n}\n"]}